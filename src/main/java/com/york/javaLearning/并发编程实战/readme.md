# 并发编程

### 1.简介
#### 使用并发的原因
- 资源利用率
- 公平性
- 便利性

#### 线程的优势

- 发挥多核处理器的强大能力
- 建模简单
- 异步事件简化处理
- 响应更灵敏的用户界面

#### 线程带来的问题

- 线程安全（原子性，可见性，有序性）
- 活跃性问题（死锁，饥饿，活锁）
- 性能问题（上下文切换）

### 2.线程安全
定义：当多个线程访问某个类时，这个类始终都能保持正确的行为，这个类就是线程安全的。

在进行共享的可变状态时需要进行正确的管理
#### 原子性

- 竞态条件

- 锁（synchnized）可重入锁，代码块，保证多个线程串行执行。
  1.每个共享和可变的变量都应该只由一个锁来保护，从而让维护人员知道是哪一个锁
  2.对于包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护
#### 活跃性与性能
- 缩小锁的使用范围，只有需要时，才进行锁定（不要盲目的为了性能而牺牲简单性）
- 当进行时间较长的计算和IO操作时，不要使用锁（清楚代码块中实现的功能，以及执行时间），
  无论是计算密集型或者是某个可能阻塞的操作，如果持有锁的时间过长，都会带来活跃性和性能的问题。
### 3.对象的共享
如何共享和发布对象，从而使他们能够安全的由多个线程同时访问。

#### 可见性（内存可见性）

- 对变量加锁保证变量内存可见性
- 使用volatile修饰变量保证可见性
  1.不会将该变量上的操作与其他内存操作一起重排序
  2.volati变量不会被缓存在寄存器或者其他内存不可见的地方，因此在读取时总会返回最新写入的值
  3.典型用法：检查某个状态标记以判断是否推出循环
  4.当且仅当满足以下所有条件时，才应该使用volatil变量
  对变量的写入操作不依赖变量的当前址，或者能确保只有单个线程更新变量的值
  该变量不会与其他变量一起纳入不变性条件中
  在访问变量时不需要加锁
#### 发布与逸出
对象还没构造完成，就被使用，不安全，在构造函数中新建和启动一个线程，将this引用传递出去，不安全

#### 线程封闭
- 不共享数据，只在单线程内访问数据，不需要同步，自动实现线程安全性
- JDBC 使用ThreadLocal来实现单线程使用每一个connection
- 局部变量（栈封闭），保证不会逸出
- 不可变对象（只有一种状态，该状态由构造函数控制）
满足以下条件时，对象才是不可变的：
  1.对象创建以后其状态就不能修改
  2.对象所有域都是final类型
  3.对象是正确创建的，this引用没有逸出
#### 并发中使用和共享对象的策略

- 线程封闭
- 只读共享
- 线程安全共享（对象内部实现同步）
- 保护对象（只能通过持有特定的锁来访问）

### 4.对象的组合

#### 4.1.线程安全的类
需要包含以下三个要素：
- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件
- 简历对象状态的并发访问管理策略

### 5.基础构建

#### 5.1 同步容器类

##### 5.1.1 容器组合操作线程安全有问题

```java
public static void deleteLast(Vector list) {
    int lastIndex = list.size() - 1;
    list.remove(lastIndex);
}

public static void getLast(Vector list) {
        int lastIndex = list.size() - 1;
        list.get(lastIndex);
}
```

并发条件下会报错。

修改为获取Vector同一个锁，保证原子操作

```java
public static void deleteLast(Vector list) {
    synchrnized(list) {
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }
    
}

public static void getLast(Vector list) {
    synchrnized(list) {
        int lastIndex = list.size() - 1;
        list.get(lastIndex);
    }
}
```

迭代时，其他线程删除了数据，也会导致错误。

容器设计为抛出一个ConcurrentModificationException()

#### 5.2 并发容器

#### 5.3 并发工具


## 第一部分 总结
- 可变状态是至关重要的：所有的并发问题都可以归结为如何协调对并发状态的访问，可变状态越少，就越容易确保线程安全
- 尽量将域声明为final，除非他们可变
- 不可变对象一定是线程安全的
- 封装有助于管理复杂性
- 用锁来保护每个可变变量
- 当保护同一个不变性的所有变量时，使用同一个锁
- 执行复合操作期间，要持有锁
- 如果多个线程访问同一个可变变量时，没有同步机制会出问题
- 不要故作聪明的去推断不需要同步

## 第二部分 结构化并发程序

### 6.任务执行




  

  
  




