# 并发编程

### 1.简介
#### 使用并发的原因
- 资源利用率
- 公平性
- 便利性

#### 线程的优势

- 发挥多核处理器的强大能力
- 建模简单
- 异步事件简化处理
- 响应更灵敏的用户界面

#### 线程带来的问题

- 线程安全（原子性，可见性，有序性）
- 活跃性问题（死锁，饥饿，活锁）
- 性能问题（上下文切换）

### 2.线程安全
定义：当多个线程访问某个类时，这个类始终都能保持正确的行为，这个类就是线程安全的。

在进行共享的可变状态时需要进行正确的管理
#### 原子性

- 竞态条件

- 锁（synchnized）可重入锁，代码块，保证多个线程串行执行。
  1.每个共享和可变的变量都应该只由一个锁来保护，从而让维护人员知道是哪一个锁
  2.对于包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护
#### 活跃性与性能
- 缩小锁的使用范围，只有需要时，才进行锁定（不要盲目的为了性能而牺牲简单性）
- 当进行时间较长的计算和IO操作时，不要使用锁（清楚代码块中实现的功能，以及执行时间），
  无论是计算密集型或者是某个可能阻塞的操作，如果持有锁的时间过长，都会带来活跃性和性能的问题。
### 3.对象的共享
如何共享和发布对象，从而使他们能够安全的由多个线程同时访问。

#### 可见性（内存可见性）

- 对变量加锁保证变量内存可见性
- 使用volatile修饰变量保证可见性
  1.不会将该变量上的操作与其他内存操作一起重排序
  2.volati变量不会被缓存在寄存器或者其他内存不可见的地方，因此在读取时总会返回最新写入的值
  3.典型用法：检查某个状态标记以判断是否推出循环
  4.当且仅当满足以下所有条件时，才应该使用volatil变量
  对变量的写入操作不依赖变量的当前址，或者能确保只有单个线程更新变量的值
  该变量不会与其他变量一起纳入不变性条件中
  在访问变量时不需要加锁
#### 发布与逸出
对象还没构造完成，就被使用，不安全，在构造函数中新建和启动一个线程，将this引用传递出去，不安全

#### 线程封闭
- 不共享数据，只在单线程内访问数据，不需要同步，自动实现线程安全性
- JDBC 使用ThreadLocal来实现单线程使用每一个connection
- 局部变量（栈封闭），保证不会逸出
- 不可变对象（只有一种状态，该状态由构造函数控制）
满足以下条件时，对象才是不可变的：
  1.对象创建以后其状态就不能修改
  2.对象所有域都是final类型
  3.对象是正确创建的，this引用没有逸出
#### 并发中使用和共享对象的策略

- 线程封闭
- 只读共享
- 线程安全共享（对象内部实现同步）
- 保护对象（只能通过持有特定的锁来访问）

### 4.对象的组合

#### 4.1.线程安全的类
需要包含以下三个要素：
- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件
- 简历对象状态的并发访问管理策略

### 5.基础构建

#### 5.1 同步容器类

##### 5.1.1 容器组合操作线程安全有问题

```java
public static void deleteLast(Vector list) {
    int lastIndex = list.size() - 1;
    list.remove(lastIndex);
}

public static void getLast(Vector list) {
        int lastIndex = list.size() - 1;
        list.get(lastIndex);
}
```

并发条件下会报错。

修改为获取Vector同一个锁，保证原子操作

```java
public static void deleteLast(Vector list) {
    synchronized(list) {
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }
    
}

public static void getLast(Vector list) {
    synchronized(list) {
        int lastIndex = list.size() - 1;
        list.get(lastIndex);
    }
}
```

迭代时，其他线程删除了数据，也会导致错误。

容器设计为抛出一个ConcurrentModificationException()

#### 5.2 并发容器

#### 5.3 并发工具


## 第一部分 总结
- 可变状态是至关重要的：所有的并发问题都可以归结为如何协调对并发状态的访问，可变状态越少，就越容易确保线程安全
- 尽量将域声明为final，除非他们可变
- 不可变对象一定是线程安全的
- 封装有助于管理复杂性
- 用锁来保护每个可变变量
- 当保护同一个不变性的所有变量时，使用同一个锁
- 执行复合操作期间，要持有锁
- 如果多个线程访问同一个可变变量时，没有同步机制会出问题
- 不要故作聪明的去推断不需要同步

## 第二部分 结构化并发程序

### 6.任务执行

Executor
ExecutorService
CompletionService
Future
Runalbe
Callable
ExecutorService.invokall(Collections<?> tasks,int timeout, unit)

### 7.取消与关闭
- 中断，安全的终止线程

#### 7.1 任务取消
如果外部代码能在某个操作正常完成之前将其置为'完成'状态。那么这个操作就称为可取消的。

取消的原因有很多：
- 用户请求取消
- 有时间限制的操作，当超时后，取消所有未完成的任务
- 应用程序事件，多个线程找解决方案，当有一个线程找到时，其他的任务都取消
- 错误，比如磁盘空间满了，所有的任务都会取消，记录当前的状态，以便稍后重新启动
- 关闭，当程序或服务关闭时，必须对正在处理和等待处理的工作执行某种操作，当前正在执行的任务将继续执行直到完成，而在立即关闭的过程中，当前的任务可能会取消。

java中没有一种安全的抢占式的方法来停止线程，只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。

- 标志位 volatile boolean cancelled;
while(!cancelled) {
  doSomething();
  }
取消策略：How，When，What：其他代码如何取消该任务（How），任务在何时检查是否已经请求了取消（When），在响应取消请求时应该执行哪些操作（What）

##### 7.1.1 中断  

上面提到的取消标志位实现，当线程一直在阻塞中，就不会执行检查标志位，也就一直不会执行

而中断（interrupt）可以实现
interrupt() 能中断目标线程，isInterrypted() 返回目标线程的中断状态，interrupted() 方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。

阻塞库的方法，入Thread.sleep和Object.wait等，都会检查线程何时中断，并且在发现中断时提前返回。他们响应中断时执行的操作有：清除中断状态，抛出InterruptedException

JVM 并不能保证阻塞方法检测到中断的速度，但是在实际情况中响应速度还是非常快的。

中断：它并不会真正的中断一个线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己（这些时刻也被称为取消点）。入wait，sleep，join等方法将严格的处理这种请求。

通常：中断是实现取消最合理的方式。标志位 + 中断

##### 7.1.2 中断策略

1。尽快退出执行流程，并把中断信息传递给调用者，从而是调用栈中的上层代码可以采取进一步的操作。
2。推迟处理中断请求，直到某个更合适的时刻，因此需要记住中断请求，并且在完成当前任务后抛出InterruptedException，或者表示已经收到请求，这保证在更新过程中发生中断时，数据结构不会被破坏。
3。线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的机制中。例如关闭方法。

##### 7.1.3 响应中断


##### 7.1.5 处理不可中断的阻塞

不可中断的阻塞：
- io包中的同步Socket I/O  虽然InputStream和OutputStream的read和write方法不会响应中断，但是通过关闭底层套接字，可以使得由于执行read或write方法而被阻塞的线程抛出一个SocketException
- io包中的同步I/O，当中断一个正在InterruptibleChannel上等待的线程时，将抛出ClosedByInterruptException并（在这条链路上的阻塞的其他线程也会抛出该异常），当关闭时，将抛出AsynchronousCloseException
- Selector 的异步IO，如果一个线程在调用Selector.select方法阻塞了，那么调用close或者wakeup方法会抛出CloeseSelectorException并提前返回
- 获取某个锁，如果线程由于等待某个内置锁而阻塞，那么将无法响应中断，因为线程认为它肯定会获得锁，所以不会理会中断请求。Lock类提供了响应中断的方法

### 8. 线程池的使用

#### 8.1 


### 15.原子变量与非阻塞同步机制

#### 15.1 锁的劣势
- 当多个线程请求锁，那么一些线程将依赖操作系统，被挂起且在稍后恢复运行，当被恢复时，必须等其他线程执行完他们的时间片后，才能被调度执行。
- 挂起和恢复线程中存在着很大的开销，并且通常有长时间的中断。  
- 一个线程在等待锁时，不能做其他事情，当持有锁的线程因为其他一些原因（缺页错误，调度延迟等），那么所有等待锁的线程将无法执行
- 锁定对于细粒度的操作来说仍然是一个高开销的机制。当竞争激烈时，调度的开销与工作开销比值会非常高。
#### CAS
- cas竞争失败时，不会阻塞线程，因此它可以决定是否重试，或者恢复操作，或者不执行任何操作。这种灵活性大大减少了活跃性问题。
- cas的主要缺点是，它将使调用者处理竞争问题，（通过重试，回退，放弃，自旋，避让），而在锁中能自动处理竞争问题。
- 难以围绕CAS正确的构造算法
  

  
  




