# 并发编程

### 1.简介
#### 使用并发的原因
- 资源利用率
- 公平性
- 便利性

#### 线程的优势

- 发挥多核处理器的强大能力
- 建模简单
- 异步事件简化处理
- 响应更灵敏的用户界面

#### 线程带来的问题

- 线程安全（原子性，可见性，有序性）
- 活跃性问题（死锁，饥饿，活锁）
- 性能问题（上下文切换）

### 2.线程安全
定义：当多个线程访问某个类时，这个类始终都能保持正确的行为，这个类就是线程安全的。

在进行共享的可变状态时需要进行正确的管理
#### 原子性

- 竞态条件

- 锁（synchnized）可重入锁，代码块，保证多个线程串行执行。
  1.每个共享和可变的变量都应该只由一个锁来保护，从而让维护人员知道是哪一个锁
  2.对于包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护
#### 活跃性与性能
- 缩小锁的使用范围，只有需要时，才进行锁定（不要盲目的为了性能而牺牲简单性）
- 当进行时间较长的计算和IO操作时，不要使用锁（清楚代码块中实现的功能，以及执行时间），
  无论是计算密集型或者是某个可能阻塞的操作，如果持有锁的时间过长，都会带来活跃性和性能的问题。
### 3.对象的共享
如何共享和发布对象，从而使他们能够安全的由多个线程同时访问。

#### 可见性（内存可见性）

- 对变量加锁保证变量内存可见性
- 使用volatile修饰变量保证可见性
  1.不会将该变量上的操作与其他内存操作一起重排序
  2.volati变量不会被缓存在寄存器或者其他内存不可见的地方，因此在读取时总会返回最新写入的值
  3.典型用法：检查某个状态标记以判断是否推出循环
  4.当且仅当满足以下所有条件时，才应该使用volatil变量
  对变量的写入操作不依赖变量的当前址，或者能确保只有单个线程更新变量的值
  该变量不会与其他变量一起纳入不变性条件中
  在访问变量时不需要加锁
#### 发布与逸出
对象还没构造完成，就被使用，不安全，在构造函数中新建和启动一个线程，将this引用传递出去，不安全

#### 线程封闭
- 不共享数据，只在单线程内访问数据，不需要同步，自动实现线程安全性
- JDBC 使用ThreadLocal来实现单线程使用每一个connection
- 局部变量（栈封闭），保证不会逸出
- 不可变对象（只有一种状态，该状态由构造函数控制）
满足以下条件时，对象才是不可变的：
  1.对象创建以后其状态就不能修改
  2.对象所有域都是final类型
  3.对象是正确创建的，this引用没有逸出
  

  
  




