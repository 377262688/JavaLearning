# NIO
新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。

## 流与块
I／O 与NIO最大区别在于 数据打包和传输的方式，一个面向流，一个面向块。

面向流的I/O一次只处理一个字节的数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据,
为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。
不利的一面是，面向流的 I/O 通常相当慢。

面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。
但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。

I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。
例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。

## 通道与缓冲区

### 1 通道
通道是对原I/O流中的流的模拟，可以通过它读取和写入数据。
通道和流的不同之处在于，流只能在一个方向上移动，（一个流必须是InputStream 或者 OutputStream 的子类），
而通道是双向的，可以用于读，写，或者同时用于读写。

通道包括以下类型：
- FileChannel:从文件中读取数据
- DatagramChannel：通过UDP读取网络中的数据
- SocketChannel：通过TCP读取网络中的数据
- ServerSocketChannel：可以监听新进来的TCP链接，对每一个新进来的链接都会创建一个SocketChannel。

### 2 缓冲区
发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。
也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。
缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

缓冲区包括以下类型：
- ByteBuffer
- CharBuffer
- ShortBuffer
- IntBuffer
- LongBuffer
- FloatBuffer
- DoubleBuffer

缓冲区的状态变量：

- capacity：最大容量；
- position：当前已经读写的字节数；
- limit：还可以读写的字节数。

状态变量改变过程举例：
1）新建一个大小为8个字节的缓冲区，此时position 为 0，而 limit = capacity = 8，capacity 变量不会改变。
![avatar](https://camo.githubusercontent.com/2a7124242c8d67203a0644255fa0c266ab047afa/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31626561333938662d313761372d346636372d613930622d3965326432343365616139612e706e67)
2) 从输入通道读取5个字节的数据进入缓冲区，此时position为5，limit 保持不变
![avatar](https://camo.githubusercontent.com/cbbc8451d44890665c19f2a38df033cb9e871ab0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303830346635322d383831352d343039362d623530362d3438656566336565643563362e706e67)
3）在将缓冲区数据写到输出通道之前，需要先调用flip() 方法，这个方法将limit设置为position，并将position设置为0。
![avatar](https://camo.githubusercontent.com/8bbcea5699a8eea9c58fc91686ba864aa3c23ff9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39353265303662642d356136352d346361622d383265342d6464313533363436326633382e706e67)
4）从缓冲区中读取4个字节到输出缓冲中，此时position为4。
![avatar](https://camo.githubusercontent.com/f075744aafa9559fffb84311e34036d6d66b9b7f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62356264636265322d623935382d346165662d393135312d3661643936336362323862342e706e67)
5）最后调用clear() 方法来清空缓冲区，此时position和limit都设置为0
![avatar](https://camo.githubusercontent.com/249f208058a7acab94a75516a404eb2dde74a816/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36376266353438372d633435642d343962362d623963302d6130353864386336383930322e706e67)